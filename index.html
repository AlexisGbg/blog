<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="layout.css">
  <title>Alexis' Blog</title>
</head>

<body>
<div id="sidebar">
	<div id="header-border">
	</div>
	<div id="header-top">
	<h1>ALEXIS' BLOG</h1>
	</div>
</div>

<div id="content-container">
<div class="post">
	<h2>Boost your machines</h2>
	<div class="has-content-area">
		<p>
		Let us assume you have a machine and you trained it to guess the weather (sunny or rainy) of a given day (with help of some indicators like humidity or temperature). Unfortunately, your machine is a bit flawed and it performs only poorly (slightly better than random guessing though). Then, unsatisfied as you are, you must trash the machine and find another one. But wait! there is another option: boost it.  
		</p>
		<p>
		If you’ve got such a machine, then it’s probably a piece of software. And what’s great about such pieces is that you can copy them indefinitely (as long as gigs are left on your hard drive). So here you go with boosting: build yourself an army of flawed machines by cloning the initial one hundred or thousand times. Then train a first machine: reward it when it makes correct guesses, punish it otherwise. Go on to a second machine but twist the rewarding process:  punish this machine harder when it makes the same mistakes as the previous one. Hopefully, if you continue the process, the pain of making the same mistakes as all others becomes so high that the newly trained machines are forced to learn something new and get it right. Continue this process until you reached the last machine.
		</p>
		<p>
		You now have a trained army of second-rate machines. Each machine is able to guess (poorly) the weather of a given day, yet all the machines won’t agree with one another (per design)… But here comes the boosting magic: make your army vote, give more weight to the machines that showed better performances during the training, and here you are with a first-rate weather prediction engine.
		</p>
	</div>
	<p class="byline">
		<span class="date">JANUARY 28, 2019</span>
	</p>
	<div class="post-footer">
		<p class="post-tags">
		#machinelearning #boosting 
		</p>
	</div>
</div>

<div class="post">
	<h2>Are you managing yourself?</h2>
	<div class="has-content-area">
		<p>
		Then you should probably know <b>1.</b> what you’re good at <b>2.</b> how you work the best and <b>3.</b> what your values are.  
		</p>
		<p>
		Now, this is usually extremely hard to find out. We never had indeed to bother about this in 2 million years of mankind history:  hunter-gatherers were born, peasants were born, kings were born. Moreover, the "what" and the "how" are tightly related: what you think you’re good at depends on how you think you work the best. Have one wrong and you’re all wrong (and this happens more than we think)
		</p>
		<p>
		These three personality-characteristics mentioned above are given to you and you can’t do much but find them. Yet, here is how you could get started: <i>a.</i> use feedback analysis to find your strength (try and learn) <i>b.</i> cast yourself in one of the listener, reader, speaker or writer categories to find out how you work the best and <i>c.</i> think about who you want to see in the mirror to discover your values (mirror test).
		</p>
		<p>
		Then you’re in position to define <b>4.</b> the contribution you want to do and and <b>5.</b> what result do you expect from yourself. These 5 points solved and you’ve managed yourself from competent to outstanding performer. (<i>Inspired from Peter F. Drucker - Managing Oneself</i>).
		</p>
	</div>
	<p class="byline">
		<span class="date">JANUARY 27, 2019</span>
	</p>
	<div class="post-footer">
		<p class="post-tags">
		#selfmanagment
		</p>
	</div>
</div>

<div class="post">
	<h2>A programming paradigm?</h2>
	<div class="has-content-area">
		<p>
		There is a misconception about programming paradigms: one often associates them to specific languages. However, a paradigm has a lot more to do with the way you write your code as with the language you use. 
		</p>
		<p>
		Let us consider two fundamental and antagonist programming paradigms: <b>imperative</b> and <b>declarative</b>. In the imperative approach, you would write your code as you would write a recipe: do this, then that and finally this. In the declarative approach, you’re focusing on describing the result: cake should be like this, have that, and contain this. Now, it doesn’t play any role if you’re using English or German to do so: as soon as the language you use is sophisticated enough to manipulate the needed concepts, you can do both. 
		</p>
		<p>
		Of course, some primitive languages like HTML or assembly aren’t sophisticated enough to let you adopt any paradigm, and you can surely say that HTML is a declarative language (it describes how a web page should look like, but leave it to the browser to build it) and that assembly is an imperative language (that describes step after step what the micro-chip should do). However, are R or Python declarative or imperative? Depends on your code!
		</p>
	</div>
	<p class="byline">
		<span class="date">JANUARY 25, 2019</span>
	</p>
	<div class="post-footer">
		<p class="post-tags">
		#programming
		</p>
	</div>
</div>
<div class = "post">
	<h2>Get control back over programmatic advertising</h2>
	<div class="has-content-area">
		<p>
		Allowing anyone in the wild internet community to display ads on your website might rightly frighten you: you surely don’t wanna break your image by being associated with some lousy businesses using your person to advertise junk products.
		</p>
		<p>
		If you want to get full control over the programmatic world, you must tie the machines making deals with the advertisers for you. A way to do so are <b>private deals</b> (also called programmatic guarenteed). They remove all the flexibility these machines have by fixing in advance <i>a.</i> who can display ads on your website and <i>b.</i> at which price. Advantage: a fully transparent deal. Drawback: you go back to a cumbersome, time consuming and manual mode where advertisers must be found and deals negotiated.
		</p>
		<p>
		Now, you might wonder what the difference is with the somehow outdated <b>Insertion Order</b> (IO) advertising? Conceptually, no difference. Technically, instead of using your homebrew ad tech solution, you use the programmatic ecosystem with slave machines having no choice but to make the exact deal you wanted. And here is the cherry: as soon as you are bored with the additional effort private deals generate, unleash the machines with a click and dive in the programmatic world back.
		</p>
	</div>
	<p class="byline">
		<span class="date">JANUARY 24, 2019</span>
	</p>
	<div class="post-footer">
		<p class="post-tags">
		#onlinemarketing #programmatic
		</p>
	</div>
</div>
<div class = "post">
	<h2>Suspicious ads on your website</h2>
		<div class="has-content-area">
		<p>
		In modern advertising, humans are replaced by machines to make deals between publishers and advertisers. Although this is a wonderful solution to scale up to the size of the Internet, this also brings some problems with it. Indeed, Internet is quite a dangerous place for naive machines ready to display any ad for money: it might ends up into you advertising doubtful websites asking for urgent donations to be transferred in bitcoins.
		</p>
		<p>
		Here, the naive machine to be blamed is the so-called <b>Supply-Side Platform</b> (SSP)... Basically, as soon as a web user appears on your website, your SSP broadcasts a message asking if anyone is interested in displaying ads for this user. Hopefully, several advertisers will respond back with an offer ($$). As a SSP is per default in a public auction mode, any advertiser can participate and the best offer will be taken by the SSP. 
		</p>
		<p>
		Now, a lot of bad ads are provided by advertisers having low budgets and not willing to pay much for the suspicious content they spread. Therefore, the hack is to define a minimum under which advertisers are not allowed to participate: the SSP then enters the <b>private auction mode</b>. If no offer is above this minimum, no ad will be displayed (and it’s better so).
		</p>
	</div>
	<p class="byline">
		<span class="date">JANUARY 23, 2019</span>
	</p>
	<div class="post-footer">
		<p class="post-tags">
		#onlinemarketing #programmatic
		</p>
	</div>
</div>
<div class = "post">
	<h2>Programmatic advertising in 5 words</h2>
	<div class="has-content-area">
		<p>
		Programmatic is the standard way to display ads on the Internet. Often wrongly taken to be complicated, the process is actually straightforward and involves at its core only four players. 
		</p>
		<p>
		As in any advertisement deal, we have <i>1.</i> <b>the advertiser</b> that has to show a product and <i>2.</i> <b>the publisher</b> willing to show products for money. However, in the Internet, two new key players have dragged themselves in-between: <i>3.</i> <b>the Demand-Side Platform</b> (DSP) and <i>4.</i> <b>the Supply-Side Platform</b> (SSP). These are robots enabling deals to be made automatically: the humans (publisher and advertiser) specify to them under which conditions they would like to cooperate (price, ad location and so on) and each time a web user is found, the DSP and SSP communicate to check these conditions and an ad is eventually displayed (or not). 
		</p>
		<p>
		This system directly brings in two advantages over old-school advertising: on the one side an advertiser has a tremendous amount of flexibility: he can change the budget and the desired ad locations at any time. On the other side, the publisher can extract the most value of its website through a <i>5.</i> <b>generalized second-price auction</b> mechanism, that automatically compares all the potential deals and chooses the one offering the most.
		</p>
	</div>
	<p class="byline">
		<span class="date">JANUARY 23, 2019</span>
	</p>
	<div class="post-footer">
		<p class="post-tags">
		#onlinemarketing #programmatic
		</p>
	</div>
</div>

</div>
</div>
</body>
</html>